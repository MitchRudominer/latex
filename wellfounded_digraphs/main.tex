\documentclass[oneside,12pt]{amsart}

\usepackage{amsmath,amssymb,latexsym,eucal,amsthm}

\input{mathdefs}
\input{theoremstyles}

\pagestyle{plain}

\begin{document}

\title{Well-Founded Two-Sorted Directed Graphs}
\author{Mitch Rudominer}

\keywords{graph theory, programming languages, compilers}

\begin{abstract}
We introduce a generalization of the notion of acyclicality in directed graphs:
the notion of a \emph{well-founded} two-sorted directed graphs. We study the
properties of well-foundedness and describe an algorithm for verifying it.

Our two-sorted graphs include two sorts of nodes: regular nodes
nodes called \emph{circle} nodes, and special nodes called \emph{square} nodes.
What makes a square node special is that rather than requiring that all
out-edges may be followed to eventually reach a leaf node (this is the
case with a regular acyclic digraph) we only require that at least one
of its out-edges have this property.

A regular digraph (that is a digraph with only regular circle nodes) is
well-founded if and only if it is acyclic. But a digraph that contains square
nodes may be well-founded and still contain some cycles that involve square
nodes.

We present one application of this theory: The analysis of the validity of
user-defined types in a programming language that includes user-defined structs and unions.
The structs are modeled as circle nodes and the unions are modelled as square
nodes. The well-foundedness of the type graph coincides with the validity
of the definition of a compound user-defined type built up from structs and unions.
\end{abstract}

\maketitle

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Square-Imposed Subgraphs}

\begin{definition}
Let $x$ be a node in a directed graph $G$. Then the subgraph of $G$ \emph{rooted at} $x$,
denoted $G_x$, is the subgraph of $G$ generated by all edges reachable from $x$.
\end{definition}

\begin{definition}
Let $x$ and $y$ be nodes in a directed graph and suppose there is an edge from
$x$ to $y$. Then we will say that $y$ is a \emph{child} of $x$ and that $x$ is a
\emph{parent} of $y$.
\end{definition}

Notice that with the above two definitions we are for convenience abusing some terminology that is
more appropriately applied in the case of a tree. In case of a general digraph the child
relationship is not asymmetric and in particular a node may be its own parent. Also
$G_x = G_y$ iff $x$ and $y$ are reachable from each other.

\begin{definition}
A \emph{two-sorted graph} is a directed graph in which the nodes are of two sorts
that we call \emph{circle} nodes and \emph{square} nodes.
\end{definition}

\begin{definition}
Let $G$ be a two-sorted graph and let $H$ be a subgraph of $G$. Then we say that
$H$ is \emph{square-imposed} iff
\begin{enumerate}
\item Every node of $G$ is a node of $H$.
\item If $x$ is a circle node of $G$ then every out-edge from $x$ is in $H$.
\item If $x$ is a square node of $G$ and if $x$ has at least one out-edge
in $G$ then $x$ has at least one out-edge in $H$.
\end{enumerate}

Thus a square-imposed subgraph is one in which the square nodes get to impose
which of their out edges they choose to throw away, subject to the constraint that
they must keep at least one. A circle node gets to make
no choices: all of its out-edges must be kept.

Notice that if $G$ is a regular digraph (that is $G$ has only circle nodes) then it
has no proper square-imposed subgraphs.

\begin{definition}
Let $G$ be a two-sorted graph. We say that $G$ is \emph{acceptable} iff $G$ has
an acyclic square-imposed subgraph. Let $x$ be a node of $G$. We say that $x$ is
acceptable iff $G_x$ is acceptable.
\end{definition}

So a regular digraph is acceptable iff it is acyclic.

\begin{theorem}
\label{Acceptability-Is-Local}
The following are equivalent.
\begin{enumerate}
\item $G$ is acceptable
\item Every node of $G$ is acceptable.
\end{enumerate}
\end{theorem}

The proof of (1) $\Implies$ (2) is easy:  An acyclic square-imposed subgraph of $G$
yields an acyclic square-imposed subgraph of $G_x$. The proof of (2) $\Implies$ (1)
is trickier because if one naively attempts to piece together a bunch of acyclic square-imposed
subgraphs the resulting larger graph need not be acyclic. We will prove this theorem in a later section.

\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Well-Founded Nodes}

In this section we give a bottom-up definition that turns out to be equivalent to the top-down
notion of acceptability given in the previous section.

We wish to define the notion of a node in a two-sorted graph being \emph{well-founded.} The following recursive property
is easy to understand and it is tempting to make it the definition of well-founded.

\begin{itemize}
\item A leaf node (i.e. a node without any children) is well-founded.
\item A circle node is well-founded iff all of its children are well-founded.
\item A non-leaf square node is well-founded iff at least one of its children are well-founded.
\end{itemize}

This recursion will turn out to be valid. However it is not logically correct to use the above clauses as the
definition of well-foundedness. This is because recursive definition may only be given with respect to
a well-founded relation. The clauses above are expressed using recursion on the child relation and this
relation is not well-founded in a digraph with cycles. Instead we give the following more formal definition
of the \emph{rank} of a node in a two-sorted graph.

\begin{definition}
Let $x$ be a node in a two-sorted graph. Then we say $\rank(x) = 0$ iff $x$ is a leaf node.
Let $n\geq 0$. We say that $\rank(x) = n+1$ iff
\begin{itemize}
\item $x$ is a circle node and for all children $y$ of $x$, $\rank(y)$ is defined and $\rank(y) <= n$ and for at least one child
$y$, $\rank(y)=n$, or
\item $x$ is a square node and it has a child $y$ such that $\rank(y) = n$ and it does not have a child
$y$ such that $\rank(y) < n$.
\end{itemize}
\end{definition}

A more concise but arguably less clear way of expressing the two bullet points in the above definition is:

\begin{itemize}
\item $x$ is a circle node and $n$ is least such that all children of $x$ have rank $\leq n$, or
\item $x$ is a square node and $n$ is least such that there exists a child of $x$ with rank $\leq n$.
\end{itemize}

\begin{definition}
Let $x$ be a node in a two-sorted graph. Then $x$ is \emph{well-founded} iff it has a rank.
\end{definition}

Unlike the informal definition of well-founded we gave above, this definition is logically sound because
the definition of the rank function proceeds by induction on the integers. The informal definition may now
be expressed properly as a lemma:

\begin{lemma}
Let $x$ be a node in a two-sorted graph $G$.  Then $x$ is well-founded iff
\begin{enumerate}
\item $x$ is a leaf node, or
\item $x$ is a circle node and all children of $x$ are well-founded, or
\item $x$ is a square node and at least one child of $x$ is well-founded.
\end{enumerate}
\end{lemma}
\begin{proof}
TODO: Write this proof.
\end{proof}

Now we can relate the bottom-up notion of well-foundedness to the top-down notion of acceptabilty.

\begin{theorem}
Let $x$ be a node in a two-sorted graph $G$. Then $x$ is acceptable iff $x$ is well-founded.
\end{theorem}
\begin{proof}
TODO: Write this proof.
\end{proof}


Now we can give the

\begin{proof}[proof of Theorem \ref{Acceptability-Is-Local}.]

TODO: Write this proof.

\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{An Algorithm for Verifying Acceptability}
In this section we outline an algorithm for determining whether two-sorted graph $G$ is acceptable.
If $G$ happens to be a regular graph (consisting of only circle nodes) then our algorithm reduces
to the usual depth-first-search algorithm for determining whether a directed graph contains a cycle.

TODO: Finish this section.

\section{An Application to Programming Languages}
In this section give an application of the theory of well-founded two-sorted graphs to the verification of the validity
of a set of user-defined types in a programming language.

TODO: Finish this section.

\end{document}